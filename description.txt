Project based on architechture of microservices. Project consists of two functional microservices(product-service and order-service) and three infrastructure microservices(api-gateway, discovery-server and configuration-server):
Configuration-server provides configurations to each unit of distributed system from central repository(I'm using Github). Also I use spring cloud bootstrap and turn properties for every microservice from application.properties to bootstrap.properties. It helps us keep all properties distinctly from application.
Discovery-server is part for registration all servers, lookup them and communication between them. I solve this issue with help of Eureka Discovery Server. When a new server is provisioned it will communicate with the discovery server and register its address so that others can communicate with it. This way other applications can consume this information as they make requests.
For centralizing accessing to microservices(entrypoint) I use api-gateway. In microservice architechture api-gateway is a server for authantication and accessing to microservices from one server. With api-gateway I use keycloak server for authentication and authorization(it provides security through all microservices). Api-gateway also provides load balancing with help of discovery server, it could direct user request to various instance of microservice depends of loading on them.
Product-service is service for control, load and store data about products. It has a redis key-value in memory database, that configured with aof and rdb for reliability. Also redis use as a cache. For product uploading and getting using multithreading.
Order-service is a service for creation and filling a carpet of products. It has a feign client that exchanges with product-service(is available product for order or not) and circuit breaker (resilience4j) for this communication. Order-service is using PostgreSQL database with two main tables(orders and products) and one table(order_product) for connection @Many-to-many relation between main tables. For database verification used flyway. For mapping entity to java class used hibernate. Also in hibernate configured second level cache with helps of ehcache.
Tracing through all microservices provides by sleuth with interface of zipkin.
Logging could be provided by ELK(elasticsearch, logback, kibana).
